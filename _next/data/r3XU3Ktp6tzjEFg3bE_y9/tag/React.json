{"pageProps":{"tag":"React","posts":[{"slug":"event-bubbling-capturing-on-react","frontmatter":{"title":"イベントキャプチャリングとバブリング（React）","categories":"tech","date":"2022-01-17","tag":["React","JavaScript","Webブラウザ"]},"content":"Reactはあまり関係ないです。\n\n筆者はReactからWebの世界に入ったため、Reactの世界観からWeb標準技術を見ることが多いですが、Reactのドキュメントを読んでいるとWeb標準なのかReactの世界の話なのかがよくわからないまま進んでしまいます。そんな状況だったので、JavaScriptの勉強を改めてしていたところに「Reactをやっていて出てきた言葉だけど、なんかよくわからないからスルーしたやつだ！」と再会を果たしたので記念にこの記事を書いています。\n\n### 例題\n\n```tsx\nfunction Hoge() {\n  return (\n    <div onClick={() => console.log(\"test\")}>\n      <p onClick={() => console.log(\"p\")} >pだよ</p>\n    </div>\n  );\n}\n```\n作成した`<p/>`をクリックすると次のようになります。これが何気なく目にしている挙動と書き方だと思います。\n\n![実行結果1](https://i.gyazo.com/63f658d09ff5f2711823f9e01fc1c2a1.png)\n\n\n次に`onClickCapture`という属性からconsole.logで結果を出力してみましょう。\n\n```tsx\nfunction Hoge() {\n  return (\n    <div onClickCapture={() => console.log(\"test\")}>\n      <p onClick={() => console.log(\"p\")} >pだよ</p>\n    </div>\n  );\n}\n```\n\nconsole.logで出力される順序が変わりました。\n\n![実行結果2](https://i.gyazo.com/3fb88bf4ba65dbc23410e35d38cf89d9.png)\n\nこれはWEBの標準仕様、DOMのイベントフローに基づいた仕様なのでvanillaJSであろうが、Reactであろうが元の考え方は一緒です。\n\n\n### イベントフロー\n`キャプチャリングフェーズ` 親から子へイベントを見ていく処理\n|\n`ターゲットフェーズ` 発生源の要素に到達した後、その要素自体の処理\n|\n`バブリングフェーズ` 発生源から親へイベントを見ていく段階\n参考: [https://www.w3.org/TR/DOM-Level-3-Events/#event-flow](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n\n### JavaScriptとReact\nJavaScriptではaddEventListenrで初心者的に何も意識せずにイベントを追加すると、バブリングフェーズでイベントが発火します。\n\nReactでも通常、ほとんどのイベントでバブリングフェーズで発火します。\n> 以下のイベントハンドラはイベント伝搬のバブリングフェーズで呼び出されます。キャプチャフェーズのイベントハンドラを登録するには、イベント名に Capture を追加します。たとえば、キャプチャフェーズでクリックイベントを処理するには onClick の代わりに onClickCapture を使用します。\n\n\n### addEventListenerの第3引数（オプション）\n第3引数にあたるものは`options`、もしくは`useCapture`のプロパティです。構造上、第3引数に急にBoolean(true/false)が現れたら、useCapture属性のことです。\n以下に引用したMDNの小難しく感じる文章もそこそこ理解できるようになったのではないでしょうか。\n\n\n- options\n  - capture\n    - Boolean値で、この型のイベントがDOMツリーで下に位置するEventTargetに配信dispatchされる前に、登録されたlistenerに配信されることを示します。\n  - once\n    - Boolean値で、listenerの呼び出しを一回のみのとしたいかどうかを値で指定します。trueを指定すると、listenerは一度実行された時に自動的に削除されます。\n- useCapture\n  - Boolean値で、この型のイベントが、DOMツリー内の下のEventTargetに配信される前に、登録されたlistenerに配信されるかどうかを示します。ツリーを上方向にバブリングしているイベントは、キャプチャーを使用するように指定されたリスナーを起動しません。イベントのバブリングとキャプチャーは、両方の要素がそのイベントのハンドラーを登録している場合に、別の要素内に入れ子になっている要素で発生するイベントを伝播する2つの方法です。イベント伝播モードは、要素がイベントを受け取る順番を決定します。詳細な説明は DOM Level 3 Events と JavaScript Event order を参照してください。指定されていない場合、useCaptureは既定でfalseとなります。\n\n\n### 参考\n- [https://uhyohyo.net/javascript/3_4.html](https://uhyohyo.net/javascript/3_4.html)\n- [https://developer.mozilla.org/ja/docs/Web/API/EventTarget/addEventListener](https://developer.mozilla.org/ja/docs/Web/API/EventTarget/addEventListener)\n- [https://ja.reactjs.org/docs/events.html](https://ja.reactjs.org/docs/events.html)\n- [https://ja.reactjs.org/blog/2020/08/10/react-v17-rc.html#no-event-pooling](https://ja.reactjs.org/blog/2020/08/10/react-v17-rc.html#no-event-pooling)\n"},{"slug":"react-webpack-skelton","frontmatter":{"title":"reactスケルトン的な","date":"2020-03-01","tag":["React"]},"content":"\n## リポジトリ\nhttps://github.com/ikmnjrd/react-webpack-skelton\n\n## 手順\n`# npm init -y`\n\n`# npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader`\n\npackage.jsonに追記\n```json\n\"build\": \"webpack\",\n\"watch\": \"webpack -w\",\n\"start\": \"webpack serve\"\n```\n\n`# npm i -S react react-dom react-router-dom @types/react @types/react-dom @types/react-router-dom`\n\ntsconfig.json作成\n```json5\n{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    // TSはECMAScript 5に変換\n    \"target\": \"ES5\",\n    // TSのモジュールはES Modulesとして出力\n    \"module\": \"ES2015\",\n    // JSXの書式を有効に設定\n    \"jsx\": \"react\",\n    \"moduleResolution\": \"node\",\n    \"lib\": [\n      \"ES2020\",\n      \"DOM\"\n    ]\n  }\n}\n```\n\n`webpack.config.js` を作成\n```js\nmodule.exports = {\n  // モード値を production に設定すると最適化された状態で、\n  // development に設定するとソースマップ有効でJSファイルが出力される\n  mode: \"development\",\n\n  // メインとなるJavaScriptファイル（エントリーポイント）\n  entry: \"./src/main.tsx\",\n  // ファイルの出力設定\n  output: {\n    //  出力ファイルのディレクトリ名\n    path: `${__dirname}/dist`,\n    // 出力ファイル名\n    filename: \"main.js\"\n  },\n  module: {\n    rules: [\n      {\n        // 拡張子 .ts もしくは .tsx の場合\n        test: /\\.tsx?$/,\n        // TypeScript をコンパイルする\n        use: \"ts-loader\"\n      }\n    ]\n  },\n  // import 文で .ts や .tsx ファイルを解決するため\n  resolve: {\n    extensions: [\".ts\", \".tsx\", \".js\", \".json\"]\n  },\n  // ES5(IE11等)向けの指定（webpack 5以上で必要）\n  target: [\"web\", \"es5\"],\n\n\t// ローカルサーバー（webpack-dev-server）\n  devServer: {\n\t\tcontentBase: `${__dirname}/dist`,\n    hotOnly: true,\n    port: 8080,\n    host: '0.0.0.0',\n  }\n};\n```\n\n`/src` 配下に  `main.tsx` を作成\n```jsx\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\n\nconst App = () => {\n  return (\n      <div>\n        <h1>Hello React!</h1>\n      </div>\n  );\n}\n\nReactDOM.render(<App/>, document.querySelector('#app'));\n```\n\n\n\n`/dist` にindex.htmlを作成\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>my-app</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <script src=\"main.js\"></script>\n  </body>\n</html>\n```\n\n\nhttps://ics.media/entry/16329/\n\nhttps://newcss.net/\n"}]},"__N_SSG":true}