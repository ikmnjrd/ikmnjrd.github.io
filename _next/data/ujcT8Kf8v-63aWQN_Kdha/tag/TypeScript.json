{"pageProps":{"tag":"TypeScript","posts":[{"slug":"esbuild-misc","frontmatter":{"title":"esbuildを触った際の雑記","description":"esbuildについての雑記","date":"2022-03-15","tag":["Node.js","JavaScript","esbuild","TypeScript"]},"content":"\nViteを使った方が楽だけど、できるだけシンプルな環境を作りたい気持ちでesbuildを触っています。\n\n\n### configファイルを作成する場合\nwatchオプションを有効にした時、ビルド情報を出力するため[logLevel](https://esbuild.github.io/api/#log-level)をinfoにすると良い。\n```javascript\n// esbuild.config.js\nconst esbuild = require('esbuild');\n\nesbuild.build({\n  logLevel: 'info',\n})\n```\n```json\n// package.json\n{\n  ...\n  \"scripts\": {\n    \"build\": \"node esbuild.config.js\",\n  }\n  ...\n}\n```\n\n\n\n### CSS Module + TypeScriptで利用したい場合\n`esbuild-css-modules-plugin`をインストールしPluginとして読み込む([GitHubリポジトリ](https://github.com/indooorsman/esbuild-css-modules-plugin))\n\n\ndeclareファイルを`src/`以下に置いておく。\n```typescript\n// index.d.ts\ndeclare module '*.css' {\n  interface IClassNames {\n    [className: string]: string\n  }\n  const classNames: IClassNames;\n  export = classNames;\n}\n```\n\n\n### 周辺用語\n- CSS modules\n- PostCSS\n\n\n### 参考文献\n- [GitHubリポジトリ - esbuild](https://github.com/evanw/esbuild)\n- [How to set up CSS Modules with esbuild](https://how-to.dev/how-to-set-up-css-modules-with-esbuild)\n- [GitHubリポジトリ - esbuild-css-modules-plugin](https://github.com/indooorsman/esbuild-css-modules-plugin))\n- [esbuild の機能が足りないならプラグインを自作すればいいじゃない](https://www.kabuku.co.jp/developers/create-your-own-esbuild-plugin)"},{"slug":"ts-jest-fail-because-import-global-jset","frontmatter":{"title":"Jest(ts-jest)で作ったはずのmockがundefinedになるエラー","description":"Jestで遭遇したエラー","date":"2022-09-19","tag":["Jest","TypeScript","JavaScript"]},"content":"### 結論\nts-jest?esmで書いてるから？とりあえずでimportするのやめよう。\n\n### 状況\nJestの右も左もわからないがfetcをmockしてゴニョゴニョしていた。  \n[公式の例](https://jestjs.io/docs/mock-function-api/#jestmockedsource)にもnode-fetchを使った例が載ってるぐらいなので、コピペして動かそうとしていたら問題発生。\n\n\n以下のエラーが発生した。\n```jsstacktrace\nTypeError: mockGetImageFromWeb.mockClear is not a function\n  23 |\n  24 |   afterEach(() => {\n> 25 |     mockGetImageFromWeb.mockClear()\n     |                         ^\n  26 |   })\n  27 |   test('should be defined', () => {\n  28 |     expect(getImageFromWeb).toBeDefined()\n```\n\nコピペしたコードはこれ\n```js\nimport {expect, jest, test} from '@jest/globals';\nimport type {fetch} from 'node-fetch';\n\njest.mock('node-fetch');\n\nlet mockedFetch: jest.Mocked<typeof fetch>;\n\nafterEach(() => {\n  mockedFetch.mockClear();\n});\n\ntest('makes correct call', () => {\n  mockedFetch = getMockedFetch();\n  // ...\n});\n\ntest('returns correct data', () => {\n  mockedFetch = getMockedFetch();\n  // ...\n});\n```\n\n\n### 対応\nコピペしてきたtestファイルで以下のインポート文を削除したら動いた。\n```js\nimport { expect, jest, test } from '@jest/globals'\n```\n\n### 参考文献\n- [Mock Functions · Jest](https://jestjs.io/docs/mock-function-api/#jestmockedsource)\n- [How To Mock Fetch in Jest | Leigh Halliday](https://www.leighhalliday.com/mock-fetch-jest)\n\n\n"},{"slug":"ts-strict-property-check","frontmatter":{"title":"TypeScriptでオブジェクトのプロパティをチェックしたい時の解決方法2選","description":"オブジェクトのプロパティを検査したい時の解決策を2つ紹介","date":"2023-05-26","tag":["TypeScript"]},"content":"\n### TL;DR\n個人的推しは2個目のこっち。\n```ts\ntype Impossible<K extends keyof any> = {\n  [P in K]: never;\n};\n\ntype NoExtraProperties<T, U extends T = T> = U & Impossible<Exclude<keyof U, keyof T>>;\n```\n\n### 解決したい事象\n次のようなコードはTypeScriptではエラーになりません。\n```ts\ninterface User {\n  name: string\n  email: string\n}\nconst user = {\n  name: 'John',\n  email: 'john@sample.example',\n  password: 'password'\n}\n\n// passwordは型定義にはない\nfunction checkUser(input: User): boolean {\n  return !!input.name && !!input.email\n}\ncheckUser(user)\n```\n\nこれでは必要のないpasswordというプロパティも取り回してしまい、不都合がある場合もあります。\n\n\n### 解決策\nstack overflowでは次の2019年に投稿された2つの解決策が支持を得ていました。\n\n#### 解決策1\n```ts\ntype StrictPropertyCheck<T, TExpected, TError> = Exclude<keyof T, keyof TExpected> extends never ? {} : TError;\n```\nこれを先ほどの例に当てはめれると次のようになります。\n```ts\nfunction checkUser<T extends User>(\n  input: T & StrictPropertyCheck<T, User, 'MyError'>\n): boolean {\n  return !!input.name && !!input.email\n}\ncheckUser(user)\n```\n\n```jsstacktrace\n型 '{ name: string; email: string; password: string; }' の引数を型 '{ name: string; email: string; password: string; } & \"MyError\"' のパラメーターに割り当てることはできません。\n  型 '{ name: string; email: string; password: string; }' を型 '\"MyError\"' に割り当てることはできません。ts(2345)\n```\n\n\n#### 解決策2\n```ts\ntype Impossible<K extends keyof any> = {\n  [P in K]: never;\n};\n\ntype NoExtraProperties<T, U extends T = T> = U & Impossible<Exclude<keyof U, keyof T>>;\n```\n例は以下\n```ts\nfunction checkUser<T extends User>(input: NoExtraProperties<User, T>): boolean {\n  return !!input.name && !!input.email\n}\ncheckUser(user)\n```\n```jsstacktrace\n型 '{ name: string; email: string; password: string; }' の引数を型 'NoExtraProperties<User, { name: string; email: string; password: string; }>' のパラメーターに割り当てることはできません。\n  型 '{ name: string; email: string; password: string; }' を型 'Impossible<\"password\">' に割り当てることはできません。\n    プロパティ 'password' の型に互換性がありません。\n      型 'string' を型 'never' に割り当てることはできません。ts(2345)\n```\nどのプロパティがエラーとなるのかがわかりやすい点と利用するときの記述の簡単さが推しポイントです。  \nその代わり、Impossibleの使い道が他に思いつかない点が少し気がかりです。  \nコチラの方が個人的には好みです。  \n\n\n### 参考文献\n- [Forcing excess-property checking on variable passed to TypeScript function - Stack Overflow](https://stackoverflow.com/questions/54775790/forcing-excess-property-checking-on-variable-passed-to-typescript-function)\n- [Is it possible to restrict TypeScript object to contain only properties defined by its class? - Stack Overflow](https://stackoverflow.com/questions/49580725/is-it-possible-to-restrict-typescript-object-to-contain-only-properties-defined)"},{"slug":"typeorm-to-me","frontmatter":{"title":"私が知ってるTypeORMについて、またはPrismaとの比較","description":"TypeORMに対して私が思ったこと","date":"2024-11-19","tag":["JavaScript","TypeScript"]},"content":"\n## はじめに\n私はTypeORMについてかなりネガティブ寄り\nな意見を持っています。  \nこれはTypeScript環境でのORMは[Prisma](https://www.prisma.io/)が1強とされる2023年、そんな時期に”Tier2以下”とされるORMを使うことを強いられたからにほかならないと思いますが、その”Tier2以下”から見える景色というのは貴重だという思いで、自分から見えた景色を書いていきます。  \nORMの厳密な定義はわかりませんが、ORMかそうじゃないかという論争をたまに見かけます。自分には判断がつかないのでTypeORMやPrismaによき期待される層のことを総称してORMとこの記事の中では呼びます。  \n\n## ここがだめだよTypeORM\n### 型が取り出しづらい\nまずTypeORMのテーブル定義はClassとデコレータで行われます。\n```ts\nimport { Entity, PrimaryGeneratedColumn, Column } from \"typeorm\"\n\n@Entity({ database: \"secondDB\" })\nexport class User {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column()\n    firstName: string\n\n    @Column()\n    lastName: string\n}\n```\n\nリレーションの記述もこれに従います。  \n\n```ts\n@Entity({ database: \"secondDB\" })\nexport class User {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column()\n    firstName: string\n\n    @Column()\n    lastName: string\n\n    @OneToMany(() => Photo, (photo) => photo.user)\n    photos: Photo[]\n}\n```\n\n次にUserテーブルから条件に一致するデータを取り出すときはこう書きます。\n```ts\nuserRepository.find({\n      where: {\n        firstName: \"Timber\",\n        lastName: \"Saw\",\n    },\n})\n```\nここにもうTypeORMの嫌なところが顔を出します。  \n上のコードの返り値からPromiseを解決させると`Userインスタンス`が現れます。  \nつまり、この型には`{ photos: Photo[] }`が含まれています。もちろん実行結果にはphotosは含まれず、relation先も含めて取得する場合はそれ用のオプションがあります。  \n最悪ですね。  \n  \n対応作はもちろんあって、元のUserからOmitしたものをベースに使用し、オプション次第で自分たちで型を組み立てるということもできるわけですが、二度手間です。Prismaならここらもうまくやってくれます。  \n\nちなみに[クエリビルダ](https://typeorm.io/update-query-builder)として使っても一緒です。（Prismaは最近クエリビルダでSQLを書いたらそのSQLに応じた型を提供してくれるようになったというニュースを最近みました。実際にまだ使ってないのでどの程度のものなにかは知りません。）  \n\n### いまだにメジャーバージョンがリリースされてない\n\nTypeORMの名前はよく聞くかと思いますが、実はまだv0.3あたりで、数年前にでました。それまでv0.1やv0.2です。  \n0.2から0.3で破壊的な変更も入っています。  \n\n## 個人的な所感\nTypeORMはTypeScriptバックエンドの初期を担ったツールという印象で、今ではもう時代遅れだと感じます。  \nその理由は自分の中で明確で、テーブル定義もTypeScriptで行おうとした点にあると思っています。  \nリレーショナルデータベースでよく使う機能に限って言っても、デコレータは使わないシンプルなTypeScriptの表現力でカバーしきれていません。そこを近道的にクラスとデコレータで表現をしたため行き詰まり、Prismaにその座を奪われたという印象です。PrismaはDSLですしね。  \nソフトウェアの栄枯盛衰のサイクルについて学びがあったような、なかったような気がします。  \n素直に時代にあった選択肢を選択しよう。  \n\n\n### 参考文献\n- [Prisma | Simplify working and interacting with databases ](https://www.prisma.io/)\n- [Update using Query Builder | TypeORM](https://typeorm.io/update-query-builder)\n"},{"slug":"typescript-compile","frontmatter":{"title":"TypeScriptをネイティブコンパイルするって？","description":"僕の疑問に追記する形で更新しています。","date":"2021-12-26","tag":["TypeScript","Deno"]},"content":"\n### 疑問\ntypescriptをjavascriptを挟まずにネイティブコードにコンパイルするようなプロジェクトはないのか？\n\n### 自分なりの回答\nないよ。\n\nDenoがTypeScriptコードをサポートしているが、中ではコンパイラが一度JavaScriptに変換している。\n\nマイクロソフトがTypeScriptコンパイラAPIをwikiにしてくれている。\n[https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)"}]},"__N_SSG":true}